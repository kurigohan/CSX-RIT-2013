head	1.9;
access;
symbols;
locks
	andy:1.9; strict;
comment	@# @;


1.9
date	2013.10.16.03.49.16;	author andy;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.16.03.09.05;	author andy;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.16.02.23.55;	author andy;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.16.02.22.40;	author andy;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.16.01.23.46;	author andy;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.15.22.24.52;	author andy;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.15.20.49.50;	author andy;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.14.20.52.19;	author andy;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.14.20.51.50;	author andy;	state Exp;
branches;
next	;


desc
@Lab 7
@


1.9
log
@fixed bug with median method
formatted test output
@
text
@/**
 * @@author Andy Nguyen
 */

import java.io.*;
import java.util.*;

public class StoreLocation {
    private int[ ] storeLocations;
   /**
   * The main method illustrates the use of a merge sort to sort a 
   * small array.
   * The <CODE>String</CODE> arguments (<CODE>args</CODE>) are not used 
   * in this implementation.
   **/
    public static void main(String[ ] args) throws IOException
    {
        String fileName;
        StoreLocation s = null;
        if( args.length >= 1 ) {
            fileName = args[0];
            ArrayList<int[]> testLocations = StoreLocation.readFile( fileName );

            for( int[] i : testLocations ) {
                s = new StoreLocation( i );
                System.out.println( s );
                System.out.println("--- Midpoint ---");
                System.out.println("optimal position:  " + s.midpoint());
                System.out.println("sum of distances customers must travel: " + 
                                                 s.totalTravelDistance( s.midpoint()));
                System.out.println("--- Median ---");
                System.out.println("optimal position:  " + s.median());
                System.out.println("sum of distances customers must travel: " + 
                                                 s.totalTravelDistance( s.median()));
                System.out.println("--- Average ---");
                System.out.println("optimal position:  " + s.average());
                System.out.println("sum of distances customers must travel: " + 
                                                 s.totalTravelDistance( s.average()));
                System.out.println();
            }


        }
        else{
            System.err.println( "Usage: StoreLocation test-file" );
            System.exit( 1 );
        }




        /*
        int[] test = { 120, 70, 170, 200, 50};
        StoreLocation s = new StoreLocation( test );

        System.out.println( s );

        System.out.println( "Midpoint: " + s.midpoint() );
        System.out.println( "Median: " + s.median() );
        System.out.println( "Average: " + s.average() );
        */
    }

    public String toString() {
        String str = "";
        for ( int i = 0; i < storeLocations.length; i++ ) {
            str += storeLocations[i] + " ";
        }
        return str;
    }

    /**
     * Default constructor
     */
    public StoreLocation() {
        storeLocations = null;
    }

    /**
     * Constructor that accepts an array of ints
     *
     * @@param      distances      array of building distances from state street      
     */
    public StoreLocation( int[] distances) {
        storeLocations = distances;
        sort();
    }


    /**
     * @@return the midpoint of the smallest and largest distance
     */
    public int midpoint() {
        if( storeLocations == null || storeLocations.length == 0 ) {
            return -1;
        }

            return ( storeLocations[0] + storeLocations[storeLocations.length-1] ) / 2;
    }

    /**
     * Get the middle distance from the sorted array, storeDisances.
     * If there are an even number of elements, then the median will be 
     * the midpoint between the middle 2 elements.
     *
     * @@return the median of the distances
     */
    public int median() {

        if( storeLocations == null || storeLocations.length == 0 ) {
            return -1;
        }

        int length = storeLocations.length;
        if( length-- % 2 == 0 ) { // even number of stores
            return  ( storeLocations[ length/2 ] + storeLocations[ length/2+1 ] ) / 2 ;
        }
        else { // odd number of stores
            return storeLocations[ length/2  ];
        }
    }

    /**
     * @@return the average of all the distances in storeLocations
     */
    public int average( ) {
        if( storeLocations == null || storeLocations.length == 0 ) {
            return -1;
        }

        int total = 0;
        for( int dist : storeLocations ) {
            total += dist;
        }
        return total / storeLocations.length;
    }

    /**
     * Sort the storeLocations array from smallest to largest.
     */
    public void sort() {
        if( storeLocations != null || storeLocations.length > 1 ) {
            mergesort( 0, storeLocations.length - 1 );
        }
    }

    /**
     * Perform a merge sort on storeLocations array.
     * This is done by recursively splitting the array in half
     * and then merging the sorted subarrays together. 
     * The subarrays are managed and created by 
     *  manipulating the index of storeLocations.
     *
     * @@param      start      start of the array to sort
     * @@param       end       end of the array to sort
     */
    public void mergesort( int start, int end )
    {
         int mid;

         if( start < end )
         {
              mid = ( start + end ) / 2;
              mergesort( start, mid );
              mergesort( mid + 1,  end );
              merge( start, mid, end );
         }
    }


    /**
     * Merge two sub arrays.
     * 
     * @@param      start      start of the first sub array
     * @@param      mid       end of first subarray ( where the array was split )
     * @@param      end       end of 2nd subarray  
     */
    public void merge( int start, int mid, int end )
    {      
        int merged[] = new int[ end + 1 ]; // array containing merged sub arrays
        int leftStart, leftEnd, rightStart, rightEnd, i, k;

        i = start; 
        // start and end index of the "left" sub array
        leftStart = start;
        leftEnd = mid;

        // start and end index of the "right" sub array
        rightStart = mid + 1;
        rightEnd = end;

        // compare first element in left array with first element in right array
        // the smaller element is added to merged repeat until either array 
        // becomes "empty"
        while( ( leftStart <= leftEnd ) && ( rightStart <= rightEnd ) ) {
            if( storeLocations[ leftStart ] <= storeLocations[ rightStart ] ) {
                merged[ i++ ] = storeLocations[ leftStart++ ];
            }
            else
            {
                merged[ i++ ] = storeLocations[ rightStart++ ];
            }
        }

        // add any remaining elements to merged
         while( leftStart <= leftEnd ) {
            merged[ i++ ] = storeLocations[ leftStart++ ];

         }
        while( rightStart <= rightEnd ) {
            merged[ i++ ] = storeLocations[ rightStart++ ];

         }
         
         // copy elements of merged to storeLocations
         for( k = start; k <= end; ++k ) { 
            storeLocations[ k ] = merged[ k ];
        }
    }

    /**
     * Calculate the sum of distances customers must travel from each location in 
     * storeLocations to the given location
     * 
     * @@param       loc      destination
     * @@return the sum of distances traveled from locations in storeLocations  to
     * given location
     */
    public int totalTravelDistance( int loc ) {
        if( storeLocations == null) {
            return -1;
        }
        int totalDist = 0;
        for( int i : storeLocations ) {
            totalDist += Math.abs( i - loc );
        }
        return totalDist;
    }


    /**
     * Read input file for locations
     *
     * @@param      fileName      name of the input file
     * @@return arraylist of arrays of locations
     */
    public static ArrayList<int[]> readFile( String fileName ) throws IOException, NumberFormatException {
        String[] strLocations = null; // set of locations as a string
        int[] intLocations = null; // set of locations as a number
        ArrayList<int[]> allLocations = new ArrayList<int[]>(); // all sets of locations
        String line; 
        BufferedReader br = null;

        try{
            br =  new BufferedReader ( new FileReader( fileName ) ) ; 
            while ( (line = br.readLine()) != null ) {
                line = line.trim().replaceAll("\\s{2,}", " "); // remove excess spaces
                strLocations = line.split(" "); // split the line into an array of strings

                intLocations = new int[ strLocations.length ]; 

                // convert the array of string locations to array of int locations
                for( int i = 0; i < strLocations.length; ++i ) {
                    intLocations[ i ] = Integer.parseInt( strLocations[ i ] );
                }
                for( int i : intLocations ) {
                   // System.out.print( i + " ");
                }
                allLocations.add( intLocations ); 
              //  System.out.println();
            }
        }
        catch( IOException e ) {
            System.err.println( "Could not open file." );
            System.exit( -1 );
        }
        catch( NumberFormatException e ){
            System.err.println( "Line contains invalid number." );
            System.exit( -1 );
        }
        finally {
            if ( br != null ) {
                br.close(); // close the file
            }
        }


        return allLocations;
    }
}



/*
 * StoreLocation.java
 * 
 * Version: 
 *     $Id: StoreLocation.java,v 1.8 2013/10/16 03:09:05 andy Exp andy $
 * 
 * Revisions: 
 *     $Log: StoreLocation.java,v $
 *     Revision 1.8  2013/10/16 03:09:05  andy
 *     Implemented readfile method
 *
 *     Revision 1.7  2013/10/16 02:23:55  andy
 *     fixed merge method
 *
 *     Revision 1.6  2013/10/16 02:22:40  andy
 *     Test statements for mergesort
 *
 *     Revision 1.5  2013/10/16 01:23:46  andy
 *     Implemented mergesort
 *
 *     Revision 1.4  2013/10/15 22:24:52  andy
 *     Added statements in main method to test midpoint, median, average
 *
 *     Revision 1.3  2013/10/15 20:49:50  andy
 *     Implemented average and midpoint methods.
 *
 *     Revision 1.2  2013/10/14 20:52:19  andy
 *     Skeleton
 *
 *
 */@


1.8
log
@Implemented readfile method
@
text
@d9 1
a9 1
    private int[ ] storeDistances;
d19 1
d24 17
a40 1

d66 2
a67 2
        for ( int i = 0; i < storeDistances.length; i++ ) {
            str += storeDistances[i] + " ";
d76 1
a76 1
        storeDistances = null;
d85 1
a85 1
        storeDistances = distances;
d94 1
a94 1
        if( storeDistances == null || storeDistances.length == 0 ) {
d98 1
a98 1
            return ( storeDistances[0] + storeDistances[storeDistances.length-1] ) / 2;
d110 1
a110 1
        if( storeDistances == null || storeDistances.length == 0 ) {
d114 1
a114 1
        int length = storeDistances.length;
d116 1
a116 1
            return  ( storeDistances[ length/2 ] + storeDistances[ length/2+1 ] ) / 2 ;
d119 1
a119 1
            return storeDistances[ length/2 + 1 ];
d124 1
a124 1
     * @@return the average of all the distances in storeDistances
d127 1
a127 1
        if( storeDistances == null || storeDistances.length == 0 ) {
d132 1
a132 1
        for( int dist : storeDistances ) {
d135 1
a135 1
        return total / storeDistances.length;
d139 1
a139 1
     * Sort the storeDistances array from smallest to largest.
d142 2
a143 2
        if( storeDistances != null || storeDistances.length > 1 ) {
            mergesort( 0, storeDistances.length - 1 );
d148 1
a148 1
     * Perform a merge sort on storeDistances array.
d152 4
a155 1
     *  manipulating the index of storeDistances.
d157 1
a157 1
    public void mergesort(int start,int end)
d173 4
d178 1
a178 1
    public void merge(int start, int mid, int end)
d196 2
a197 2
            if( storeDistances[ leftStart ] <= storeDistances[ rightStart ] ) {
                merged[ i++ ] = storeDistances[ leftStart++ ];
d201 1
a201 1
                merged[ i++ ] = storeDistances[ rightStart++ ];
d207 1
a207 1
            merged[ i++ ] = storeDistances[ leftStart++ ];
d211 1
a211 1
            merged[ i++ ] = storeDistances[ rightStart++ ];
d215 1
a215 1
         // copy elements of merged to storeDistances
d217 1
a217 1
            storeDistances[ k ] = merged[ k ];
d221 19
d241 6
d298 1
a298 1
 *     $Id: StoreLocation.java,v 1.7 2013/10/16 02:23:55 andy Exp andy $
d302 3
@


1.7
log
@fixed merge method
@
text
@d5 3
d16 17
a32 2
   public static void main(String[ ] args)
   {
a33 2
      int[] test = { 120, 70, 170, 200, 50};
      StoreLocation s = new StoreLocation( test );
d35 3
a37 1
      System.out.println( s );
d39 7
a45 4
      System.out.println( "Midpoint: " + s.midpoint() );
      System.out.println( "Median: " + s.median() );
      System.out.println( "Average: " + s.average() );
   }
d197 44
d249 1
a249 1
 *     $Id: StoreLocation.java,v 1.6 2013/10/16 02:22:40 andy Exp andy $
d253 3
@


1.6
log
@Test statements for mergesort
@
text
@d138 1
a146 3
        i = start; 


a160 11
/*        if( leftStart > leftEnd ) {
            for( k = rightStart; k <= rightEnd; ++k ) {
                merged[ i++ ] = storeDistances[ k ];
            }
        }
         else {
            for( k = leftStart; k <= leftEnd; ++k ) {
                merged[ i++ ] = storeDistances[ k ];
            }
         } */

a164 1

a175 44

    /**
     * Merge two sub arrays.
     */
    public void merge2(int start, int mid, int end)
    {
         int h, i, j, k;
         int b[] = new int[ 50 ];
         h = start;
         i = start;
         j = mid + 1;

         while( ( h <= mid ) && ( j <= end ) ) {
            if( storeDistances[ h ] <= storeDistances[ j ] ) {
               b[ i ] = storeDistances[ h ];
               ++h;
            }
            else
            {
               b[ i ] = storeDistances[ j ];
               ++j;
            }
            ++i;
        }


        if( h > mid ) {
            for( k = j; k <= end; ++k ) {
                b[ i ] = storeDistances[ k ];
                ++i;
            }
        }
         else {
            for( k = h; k <= mid; ++k ) {
                b[ i ] = storeDistances[ k ];
                ++i;
            }
         }
         
         for( k = start; k <= end; ++k ) { 
            storeDistances[ k ] = b[ k ];
        }
    }

d184 1
a184 1
 *     $Id: StoreLocation.java,v 1.5 2013/10/16 01:23:46 andy Exp andy $
d188 3
@


1.5
log
@Implemented mergesort
@
text
@a5 3

    private final String BLANKS = "  "; // A String of two blanks

d16 1
a16 1
      int[] test = { 1000, 80, 12, 11, 123, 780, 41, 32, 75, 90, 20, 30, 40, 0, -1000 };
a17 4
            // Print the array before sorting:
      System.out.println("Here is the entire original array:");
      s.display();

d19 1
a19 1
      s.sort();
d21 3
a23 17

      System.out.println("I have sorted all but the first and last numbers.");
      System.out.println("The numbers are now:");
      s.display();
   }
   public void display() {

      for (int i = 0; i < storeDistances.length; i++)
         System.out.print(storeDistances[i] + BLANKS);
      System.out.println( );
   }
   public String toString() {

      for (int i = 0; i < storeDistances.length; i++)
         System.out.print(storeDistances[i] + BLANKS);
      System.out.println( );
      return "";
d26 7
d34 4
a37 1
     public StoreLocation() {
d41 7
a47 2
    public StoreLocation( int[] locations ) {
        storeDistances = locations;
d52 3
a54 1

d63 7
d85 3
d100 3
d109 8
a116 1
    public void mergesort(int low,int high)
d120 1
a120 1
         if( low < high )
d122 4
a125 4
              mid = ( low + high ) / 2;
              mergesort( low, mid );
              mergesort( mid + 1,  high );
              merge( low, mid, high );
d128 67
a194 1
    public void merge(int low,int mid,int high)
d198 2
a199 2
         h = low;
         i = low;
d202 1
a202 1
         while( ( h <= mid ) && ( j <= high ) ) {
d205 1
a205 1
               h++;
d210 1
a210 1
               j++;
d212 1
a212 1
            i++;
d217 1
a217 1
            for( k = j; k <= high; k++) {
d219 1
a219 1
                i++;
d223 1
a223 1
            for( k = h; k <= mid; k++) {
d225 1
a225 1
                i++;
d229 1
a229 1
         for( k = low; k <= high; k++ ) { 
d242 1
a242 1
 *     $Id: StoreLocation.java,v 1.4 2013/10/15 22:24:52 andy Exp andy $
d246 3
@


1.4
log
@Added statements in main method to test midpoint, median, average
@
text
@d7 1
a7 1
    private int[] storeLocations;
d9 37
a46 6
    public static void main( String args[] ) {
        int[] loc = {  70, 120, 170, 200 };
        StoreLocation s = new StoreLocation( loc );
        System.out.println( "Midpoint: " + s.midpoint() );
        System.out.println( "Median: " + s.median() );
        System.out.println( "Average: " + s.average() );
d48 2
a49 4
    }

    public StoreLocation() {
        storeLocations = null;
d53 1
a53 1
        storeLocations = locations;
d57 1
a57 4
    public StoreLocation( String fileName ) {
        storeLocations = readFile( fileName );
        sort();
    }
d60 1
a60 1
        if( storeLocations == null || storeLocations.length == 0 ) {
d64 1
a64 1
            return ( storeLocations[0] + storeLocations[storeLocations.length-1] ) / 2;
d69 1
a69 1
        if( storeLocations == null || storeLocations.length == 0 ) {
d73 1
a73 1
        int length = storeLocations.length;
d75 1
a75 1
            return  ( storeLocations[ length/2 ] + storeLocations[ length/2+1 ] ) / 2 ;
d78 1
a78 1
            return storeLocations[ length/2 + 1 ];
d83 1
a83 1
        if( storeLocations == null || storeLocations.length == 0 ) {
d88 1
a88 1
        for( int dist : storeLocations ) {
d91 1
a91 1
        return total / storeLocations.length;
d94 4
a97 2
    public int[] readFile( String fileName ) {
        return null;
d100 32
a131 2
    private void sort( ) {
        if( storeLocations != null || storeLocations.length == 1 ) {
d134 15
d152 1
a152 1
    private void merge() {
a153 3
    }

}
d160 1
a160 1
 *     $Id: StoreLocation.java,v 1.3 2013/10/15 20:49:50 andy Exp andy $
d164 3
@


1.3
log
@Implemented average and midpoint methods.
@
text
@d11 5
a15 1

d24 2
a25 1

d29 2
a30 1

d35 1
a35 1
            return -1
d48 2
a49 2
        if( length % 2 == 0 ) { // even number of stores
            return  ( storeLocations[ length/2 ] + storeLocations[ length/2+1 ] ) / 2 ];
a53 1
        return 0;
d57 1
a57 1
        if( storeLocations != null || storeLocations.length == 0 ) {
d68 6
a73 1
    public void readFile( String fileName ) {
d75 2
d79 1
a79 1
    private void sort() {
d90 1
a90 1
 *     $Id: StoreLocation.java,v 1.2 2013/10/14 20:52:19 andy Exp andy $
d94 3
@


1.2
log
@Skeleton
@
text
@d7 3
d15 11
d28 5
a32 1
        return 0;
d36 12
d52 9
a60 1
        return 0;
d63 1
a63 1
    private void readFile() {
d67 3
a69 1
    
d78 1
a78 1
 *     $Id$
d81 4
a84 1
 *     $Log$
@


1.1
log
@Initial revision
@
text
@d5 1
d7 25
@
