head	1.6;
access;
symbols;
locks
	andy:1.6; strict;
comment	@# @;


1.6
date	2013.11.22.22.11.07;	author andy;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.22.21.51.10;	author andy;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.22.21.47.20;	author andy;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.22.21.45.07;	author andy;	state Exp;
branches;
next	1.2;

1.2
date	2013.11.22.19.48.40;	author andy;	state Exp;
branches;
next	1.1;

1.1
date	2013.11.21.20.59.46;	author andy;	state Exp;
branches;
next	;


desc
@Puzzle Solver Project part 2
@


1.6
log
@Added printSolution and toString method.
@
text
@/**
 * The Water class represents a water puzzle.  The water puzzle poses the following problem:
 *
 * Assume you are at a lake and have a collection of empty jugs that can each hold different 
 * amounts of water. The goal is to get a desired amount of water in any one of the jugs using 
 * the shortest number of steps. A single step consists of  one of the following actions:
 * 
 *  - Fill a single jug up to complete capacity by submerging it in the lake.
 *  - Empty a single jug by dumping all water in the jug into the lake.
 *  - Pour the contents of any one jug into another jug, without exceeding the capacity of the 
 *    jug being poured into.
 *
 * @@author Andy Nguyen
 */

import java.util.ArrayList;

public class Water implements Puzzle<ArrayList<Integer>>{

    private int goalAmount = 0;
    private ArrayList<Integer> jugsCapacity = null;

    /**
     * Constructor for Water.
     *
     * @@param      myAmount    goal amount
     * @@param      myJugs          list of jugs    
     */
    public Water( int myAmount, ArrayList<Integer> myJugs ) {
        goalAmount = myAmount;
        jugsCapacity = myJugs;
    }

    /**
     * @@return the starting jugs config (all jugs empty)
     */
    public ArrayList<Integer> getStart(){
        ArrayList<Integer> start = new ArrayList<Integer>( jugsCapacity.size() );

        for( int i = 0; i < jugsCapacity.size(); ++i ) {
            start.add( 0 );
        }
        return  start;
    }

    /**
     * @@return the goal config 
     */
    public boolean isGoal( ArrayList<Integer> config ){
        for( int i = 0; i < config.size(); ++i ) {
            if( goalAmount == config.get(i)){
                return true;
            }
        }

        return false;
    }


    /**
     * Generate and return all direct neighbors for the given jugs config.  
     *
     * @@param config       puzzle config     
     * @@return the list of neighbors
     */
    public ArrayList<ArrayList<Integer>> getNeighbors( ArrayList<Integer> config ) {
        // list of neighbor configs
        ArrayList<ArrayList<Integer>> neighbors = new ArrayList<ArrayList<Integer>>();
        // neighbor config
        ArrayList<Integer> possibleConfig;// = new ArrayList<Integer>( config );
        int currentJug;

        for( int i = 0; i < config.size(); ++i ) {
            currentJug = config.get( i );
           
            if( currentJug > 0 ) {
                 // ****  emptying the jug ****
                // restore the config to the original to the original given config
                possibleConfig = new ArrayList<Integer>( config ); 
                possibleConfig.set( i, 0 );
                neighbors.add( possibleConfig );

                // **** pouring one jug into another jug ****
                int total; // total water amount after pouring
                int limit; // max capacity of the receiving jug
                int receiver; // current capacity of receiving jug
                int pourer; //  capacity of pouring jug

                for( int j = 0; j < config.size(); ++j ) {
                    if( j != i ) { // skip over the current jug
                        pourer = currentJug;
                        // restore the config to the original  given config
                        possibleConfig = new ArrayList<Integer>( config );

                        limit = jugsCapacity.get( j );
                        receiver = possibleConfig.get( j );

                        // check if the jug to fill is full
                        if( receiver < limit ) {
                            total = pourer + receiver;
                            // check if pouring causes jug to exceed its capacity
                            if( total > limit ) {
                                receiver = limit;
                                pourer = total - limit;
                            }
                            else{
                                receiver = total;
                                pourer = 0;
                            }

                            possibleConfig.set( j, receiver );
                            possibleConfig.set( i, pourer );
                            neighbors.add( possibleConfig );
                        } // end inner foor loop
                    }
                } // end outer for loop

            }

            if( currentJug < jugsCapacity.get(i) ) {
                // **** filling the jug ****
                possibleConfig = new ArrayList<Integer>( config );
                possibleConfig.set( i, jugsCapacity.get( i ) );
                neighbors.add( possibleConfig );
            }

        } // end for loop that interates through the config

        return neighbors;
    }

    /**
     * Prints the solution to the puzzle.
     *
     * @@param solution      solution to print
     */
    public void printSolution( ArrayList<ArrayList<Integer>> solution ) {
        int stepCount = 0; // step counter
        if( solution.size() > 0 ) {
            for( ArrayList<Integer> s : solution ) {
                System.out.print( "Step " + stepCount++ + ": ");
                for( Integer i : s ) {
                    System.out.print( i + " " );
                }
                System.out.println();
            }
        }
        else {
            System.out.println( "No solution." );
        }
    }



    /**
     * @@return string containing goalAmount and jugsCapacity.
     */
    public String toString() {
        return "Goal: " + goalAmount + "\nJugs: " +  jugsCapacity;
    }



    /**
     * Main method that gets arguments from the user and solves the puzzle.
     *
     * @@param args      command line arguments
     */
    public static void main( String args[] ) throws NumberFormatException{
        if( args.length > 1 ) {
            try{
                int goal = Integer.parseInt( args[0] );

                // create list of jugs from the command arguments
                ArrayList<Integer> jugs = new ArrayList<Integer>( args.length );
                for( int i = 1; i < args.length; ++i ) {
                    jugs.add( Integer.parseInt( args[i] ) );
                }

                Water puzzle = new Water( goal, jugs );
                Solver<ArrayList<Integer>> solver = new Solver<ArrayList<Integer>>( puzzle );
                // find and print solution
                puzzle.printSolution( solver.findSolution() );


            }
            catch( NumberFormatException e ) {
                System.err.println( "Invalid arguments." );
            }
        }
        else {
            System.err.println( "Usage: java Water amount jug1 jug2 ..." );
        }
    }
}


/*
 * Water.java
 * 
 * Version: 
 *     $Id: Water.java,v 1.5 2013/11/22 21:51:10 andy Exp andy $
 * 
 * Revisions: 
 *     $Log: Water.java,v $
 *     Revision 1.5  2013/11/22 21:51:10  andy
 *     implement isGoal method
 *
 *     Revision 1.4  2013/11/22 21:47:20  andy
 *     testing
 *
 *     Revision 1.3  2013/11/22 21:45:07  andy
 *     Implemented methods
 *
 *     Revision 1.2  2013/11/22 19:48:40  andy
 *     Skeleton
 *
 *     Revision 1.1  2013/11/21 20:59:46  andy
 *     Initial revision
 *
 *
 */ @


1.5
log
@implement isGoal method
@
text
@d132 31
d182 2
a183 2
                solver.findSolution();
                solver.printSolution();
a184 12
                /*
                ArrayList<Integer> testConfig = new ArrayList<Integer>();
                testConfig.add( 0  );
                testConfig.add( 0 );
                testConfig.add( 0 );
                ArrayList<ArrayList<Integer>> testNeighbors = puzzle.getNeighbors( jugs );

                System.out.println( "Testing: " );
                for( ArrayList<Integer> i : testNeighbors ) {
                    System.out.println( i );
                }
                */
d202 1
a202 1
 *     $Id: Water.java,v 1.4 2013/11/22 21:47:20 andy Exp andy $
d206 3
@


1.4
log
@testing
@
text
@d50 7
a56 1
        return true;
d150 3
d154 1
d165 1
d183 1
a183 1
 *     $Id: Water.java,v 1.3 2013/11/22 21:45:07 andy Exp andy $
d187 3
@


1.3
log
@Implemented methods
@
text
@d64 1
a64 1
        ArrayList<Integer> neighborConfig;// = new ArrayList<Integer>( config );
d71 5
a75 4
                 // ---  emptying the jug ---
                neighborConfig = new ArrayList<Integer>( config ); // restore the config to the original 
                neighborConfig.set( i, 0 );
                neighbors.add( neighborConfig );
d77 1
a77 1
                // --- pouring one jug into another jug ---
d82 1
d86 2
a87 1
                        neighborConfig = new ArrayList<Integer>( config );
d90 1
a90 1
                        receiver = neighborConfig.get( j );
d105 3
a107 3
                            neighborConfig.set( j, receiver );
                            neighborConfig.set( i, pourer );
                            neighbors.add( neighborConfig );
d115 4
a118 4
                // --- filling the jug ---
                neighborConfig = new ArrayList<Integer>( config );
                neighborConfig.set( i, jugsCapacity.get( i ) );
                neighbors.add( neighborConfig );
d172 1
a172 1
 *     $Id: Water.java,v 1.2 2013/11/22 19:48:40 andy Exp andy $
d176 3
@


1.2
log
@Skeleton
@
text
@d4 3
a6 3
 * Assume you are at a  lake and have a collection of empty jugs that can each hold different amounts of water. 
 * The goal is to get a  desired amount of water in any one of the jugs using the shortest number of steps. 
 * A single step consists of  one of the following actions:
d10 2
a11 1
 *  - Pour the contents of any one jug into another jug, without exceeding the capacity of the jug being poured into.
d21 1
a21 1
    private ArrayList<Integer> jugs = null;
d23 6
d31 1
a31 1
        jugs = myJugs;
d34 3
d38 6
a43 1
        return null;
d46 3
d53 68
a120 3
    public ArrayList<ArrayList<Integer>> getNeighbors( ArrayList<Integer> config ){
   
        return null;
d123 39
d169 1
a169 1
 *     $Id: Water.java,v 1.1 2013/11/21 20:59:46 andy Exp andy $
d173 3
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
import java.util.*;
d17 1
a17 1
public class Water implements Puzzle{
d19 6
a24 3
    // Get goal config for the puzzle.
    public int getStart(){
        return 0;
d27 2
a28 3
    // For an incoming config, generate and return all direct neighbors to this config.
    public int getGoal(){
        return 0;
d31 6
a36 2
    // Get starting config for the puzzle.
    public ArrayList<Integer> getNeighbors( int config ){
d47 1
a47 1
 *     $Id$
d50 4
a53 1
 *     $Log$
d55 1
a55 1
 */@
